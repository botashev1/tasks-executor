// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: proto/task_executor.proto

package taskexecutor

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TaskExecutorManager_AddTask_FullMethodName          = "/taskexecutor.TaskExecutorManager/AddTask"
	TaskExecutorManager_GetTaskStatus_FullMethodName    = "/taskexecutor.TaskExecutorManager/GetTaskStatus"
	TaskExecutorManager_RegisterExecutor_FullMethodName = "/taskexecutor.TaskExecutorManager/RegisterExecutor"
	TaskExecutorManager_GetNextTask_FullMethodName      = "/taskexecutor.TaskExecutorManager/GetNextTask"
	TaskExecutorManager_UpdateTaskStatus_FullMethodName = "/taskexecutor.TaskExecutorManager/UpdateTaskStatus"
	TaskExecutorManager_CreateExecutor_FullMethodName   = "/taskexecutor.TaskExecutorManager/CreateExecutor"
	TaskExecutorManager_UpdateExecutor_FullMethodName   = "/taskexecutor.TaskExecutorManager/UpdateExecutor"
	TaskExecutorManager_GetExecutor_FullMethodName      = "/taskexecutor.TaskExecutorManager/GetExecutor"
	TaskExecutorManager_ListExecutors_FullMethodName    = "/taskexecutor.TaskExecutorManager/ListExecutors"
	TaskExecutorManager_DeleteExecutor_FullMethodName   = "/taskexecutor.TaskExecutorManager/DeleteExecutor"
)

// TaskExecutorManagerClient is the client API for TaskExecutorManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Task Executor Service - Manager API
type TaskExecutorManagerClient interface {
	// Task Management
	AddTask(ctx context.Context, in *AddTaskRequest, opts ...grpc.CallOption) (*AddTaskResponse, error)
	GetTaskStatus(ctx context.Context, in *GetTaskStatusRequest, opts ...grpc.CallOption) (*GetTaskStatusResponse, error)
	// Executor Management
	RegisterExecutor(ctx context.Context, in *RegisterExecutorRequest, opts ...grpc.CallOption) (*RegisterExecutorResponse, error)
	GetNextTask(ctx context.Context, in *GetNextTaskRequest, opts ...grpc.CallOption) (*GetNextTaskResponse, error)
	UpdateTaskStatus(ctx context.Context, in *UpdateTaskStatusRequest, opts ...grpc.CallOption) (*UpdateTaskStatusResponse, error)
	// Executor Configuration
	CreateExecutor(ctx context.Context, in *CreateExecutorRequest, opts ...grpc.CallOption) (*CreateExecutorResponse, error)
	UpdateExecutor(ctx context.Context, in *UpdateExecutorRequest, opts ...grpc.CallOption) (*UpdateExecutorResponse, error)
	GetExecutor(ctx context.Context, in *GetExecutorRequest, opts ...grpc.CallOption) (*GetExecutorResponse, error)
	ListExecutors(ctx context.Context, in *ListExecutorsRequest, opts ...grpc.CallOption) (*ListExecutorsResponse, error)
	DeleteExecutor(ctx context.Context, in *DeleteExecutorRequest, opts ...grpc.CallOption) (*DeleteExecutorResponse, error)
}

type taskExecutorManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskExecutorManagerClient(cc grpc.ClientConnInterface) TaskExecutorManagerClient {
	return &taskExecutorManagerClient{cc}
}

func (c *taskExecutorManagerClient) AddTask(ctx context.Context, in *AddTaskRequest, opts ...grpc.CallOption) (*AddTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTaskResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_AddTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) GetTaskStatus(ctx context.Context, in *GetTaskStatusRequest, opts ...grpc.CallOption) (*GetTaskStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTaskStatusResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_GetTaskStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) RegisterExecutor(ctx context.Context, in *RegisterExecutorRequest, opts ...grpc.CallOption) (*RegisterExecutorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterExecutorResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_RegisterExecutor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) GetNextTask(ctx context.Context, in *GetNextTaskRequest, opts ...grpc.CallOption) (*GetNextTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNextTaskResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_GetNextTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) UpdateTaskStatus(ctx context.Context, in *UpdateTaskStatusRequest, opts ...grpc.CallOption) (*UpdateTaskStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTaskStatusResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_UpdateTaskStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) CreateExecutor(ctx context.Context, in *CreateExecutorRequest, opts ...grpc.CallOption) (*CreateExecutorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateExecutorResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_CreateExecutor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) UpdateExecutor(ctx context.Context, in *UpdateExecutorRequest, opts ...grpc.CallOption) (*UpdateExecutorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateExecutorResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_UpdateExecutor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) GetExecutor(ctx context.Context, in *GetExecutorRequest, opts ...grpc.CallOption) (*GetExecutorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExecutorResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_GetExecutor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) ListExecutors(ctx context.Context, in *ListExecutorsRequest, opts ...grpc.CallOption) (*ListExecutorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExecutorsResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_ListExecutors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskExecutorManagerClient) DeleteExecutor(ctx context.Context, in *DeleteExecutorRequest, opts ...grpc.CallOption) (*DeleteExecutorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteExecutorResponse)
	err := c.cc.Invoke(ctx, TaskExecutorManager_DeleteExecutor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskExecutorManagerServer is the server API for TaskExecutorManager service.
// All implementations must embed UnimplementedTaskExecutorManagerServer
// for forward compatibility.
//
// Task Executor Service - Manager API
type TaskExecutorManagerServer interface {
	// Task Management
	AddTask(context.Context, *AddTaskRequest) (*AddTaskResponse, error)
	GetTaskStatus(context.Context, *GetTaskStatusRequest) (*GetTaskStatusResponse, error)
	// Executor Management
	RegisterExecutor(context.Context, *RegisterExecutorRequest) (*RegisterExecutorResponse, error)
	GetNextTask(context.Context, *GetNextTaskRequest) (*GetNextTaskResponse, error)
	UpdateTaskStatus(context.Context, *UpdateTaskStatusRequest) (*UpdateTaskStatusResponse, error)
	// Executor Configuration
	CreateExecutor(context.Context, *CreateExecutorRequest) (*CreateExecutorResponse, error)
	UpdateExecutor(context.Context, *UpdateExecutorRequest) (*UpdateExecutorResponse, error)
	GetExecutor(context.Context, *GetExecutorRequest) (*GetExecutorResponse, error)
	ListExecutors(context.Context, *ListExecutorsRequest) (*ListExecutorsResponse, error)
	DeleteExecutor(context.Context, *DeleteExecutorRequest) (*DeleteExecutorResponse, error)
	mustEmbedUnimplementedTaskExecutorManagerServer()
}

// UnimplementedTaskExecutorManagerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskExecutorManagerServer struct{}

func (UnimplementedTaskExecutorManagerServer) AddTask(context.Context, *AddTaskRequest) (*AddTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTask not implemented")
}
func (UnimplementedTaskExecutorManagerServer) GetTaskStatus(context.Context, *GetTaskStatusRequest) (*GetTaskStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskStatus not implemented")
}
func (UnimplementedTaskExecutorManagerServer) RegisterExecutor(context.Context, *RegisterExecutorRequest) (*RegisterExecutorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterExecutor not implemented")
}
func (UnimplementedTaskExecutorManagerServer) GetNextTask(context.Context, *GetNextTaskRequest) (*GetNextTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextTask not implemented")
}
func (UnimplementedTaskExecutorManagerServer) UpdateTaskStatus(context.Context, *UpdateTaskStatusRequest) (*UpdateTaskStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTaskStatus not implemented")
}
func (UnimplementedTaskExecutorManagerServer) CreateExecutor(context.Context, *CreateExecutorRequest) (*CreateExecutorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExecutor not implemented")
}
func (UnimplementedTaskExecutorManagerServer) UpdateExecutor(context.Context, *UpdateExecutorRequest) (*UpdateExecutorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExecutor not implemented")
}
func (UnimplementedTaskExecutorManagerServer) GetExecutor(context.Context, *GetExecutorRequest) (*GetExecutorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExecutor not implemented")
}
func (UnimplementedTaskExecutorManagerServer) ListExecutors(context.Context, *ListExecutorsRequest) (*ListExecutorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExecutors not implemented")
}
func (UnimplementedTaskExecutorManagerServer) DeleteExecutor(context.Context, *DeleteExecutorRequest) (*DeleteExecutorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExecutor not implemented")
}
func (UnimplementedTaskExecutorManagerServer) mustEmbedUnimplementedTaskExecutorManagerServer() {}
func (UnimplementedTaskExecutorManagerServer) testEmbeddedByValue()                             {}

// UnsafeTaskExecutorManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskExecutorManagerServer will
// result in compilation errors.
type UnsafeTaskExecutorManagerServer interface {
	mustEmbedUnimplementedTaskExecutorManagerServer()
}

func RegisterTaskExecutorManagerServer(s grpc.ServiceRegistrar, srv TaskExecutorManagerServer) {
	// If the following call pancis, it indicates UnimplementedTaskExecutorManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskExecutorManager_ServiceDesc, srv)
}

func _TaskExecutorManager_AddTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).AddTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_AddTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).AddTask(ctx, req.(*AddTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_GetTaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).GetTaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_GetTaskStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).GetTaskStatus(ctx, req.(*GetTaskStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_RegisterExecutor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterExecutorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).RegisterExecutor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_RegisterExecutor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).RegisterExecutor(ctx, req.(*RegisterExecutorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_GetNextTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).GetNextTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_GetNextTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).GetNextTask(ctx, req.(*GetNextTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_UpdateTaskStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).UpdateTaskStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_UpdateTaskStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).UpdateTaskStatus(ctx, req.(*UpdateTaskStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_CreateExecutor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExecutorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).CreateExecutor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_CreateExecutor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).CreateExecutor(ctx, req.(*CreateExecutorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_UpdateExecutor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExecutorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).UpdateExecutor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_UpdateExecutor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).UpdateExecutor(ctx, req.(*UpdateExecutorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_GetExecutor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExecutorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).GetExecutor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_GetExecutor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).GetExecutor(ctx, req.(*GetExecutorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_ListExecutors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExecutorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).ListExecutors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_ListExecutors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).ListExecutors(ctx, req.(*ListExecutorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskExecutorManager_DeleteExecutor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExecutorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskExecutorManagerServer).DeleteExecutor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskExecutorManager_DeleteExecutor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskExecutorManagerServer).DeleteExecutor(ctx, req.(*DeleteExecutorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskExecutorManager_ServiceDesc is the grpc.ServiceDesc for TaskExecutorManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskExecutorManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "taskexecutor.TaskExecutorManager",
	HandlerType: (*TaskExecutorManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddTask",
			Handler:    _TaskExecutorManager_AddTask_Handler,
		},
		{
			MethodName: "GetTaskStatus",
			Handler:    _TaskExecutorManager_GetTaskStatus_Handler,
		},
		{
			MethodName: "RegisterExecutor",
			Handler:    _TaskExecutorManager_RegisterExecutor_Handler,
		},
		{
			MethodName: "GetNextTask",
			Handler:    _TaskExecutorManager_GetNextTask_Handler,
		},
		{
			MethodName: "UpdateTaskStatus",
			Handler:    _TaskExecutorManager_UpdateTaskStatus_Handler,
		},
		{
			MethodName: "CreateExecutor",
			Handler:    _TaskExecutorManager_CreateExecutor_Handler,
		},
		{
			MethodName: "UpdateExecutor",
			Handler:    _TaskExecutorManager_UpdateExecutor_Handler,
		},
		{
			MethodName: "GetExecutor",
			Handler:    _TaskExecutorManager_GetExecutor_Handler,
		},
		{
			MethodName: "ListExecutors",
			Handler:    _TaskExecutorManager_ListExecutors_Handler,
		},
		{
			MethodName: "DeleteExecutor",
			Handler:    _TaskExecutorManager_DeleteExecutor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/task_executor.proto",
}
